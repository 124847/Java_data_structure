package 算法分析;

/*
如何花更少的时间,如何占用更少的内存取完成相同的需求

//时间复杂度的分析
事后分析法
机器运行一次计算时间
受外界因素影响大
事前分析法
核心操作次数和输入规模关联起来
随着输入规模的增大，
算法的常数操作可以忽略不记
最高项的常数因子可以忽略
最高次项的指数大的，随着n的增长，结果也会变得增长特别快
n最高次幂越小，算法效率越高
大O记法
记作：T(n) = O(f(n))

用常数1取代运行时间种的所有加法常数
在修改后的运行次数中，只保留高阶项
把最高阶的常数变为1
顺序从小到大
常数阶     普通语句 将两个数相加
对数阶     二分策略 二分查找
线性阶     循环     找出最大值
线性乘对数阶 分治思想 归并排序
后面的是不可取的，需要进行优化
平方阶     双层循环  检查所有元素对
立方阶     三层循环  检查所有三元组
指数级别    穷举查找   检查所有子集

算法的空间复杂度
Date date = new Date()
date这个变量需要八字节保存
除了Date()内部存储的数据要存内存 该对象本身也有内存开销，每个对象的自身开销是16个字节，用来保存对象的头部信息
一般内存的使用以8字节为单位，所以总是8字节的倍数
常见的java数组就是这样 16个头部信息字节 4个字节表示长度 必须为8的倍数，所以扩充为24个字节
 */
//
public class 算法概述 {
    public static void main(String[] args) {
//        第一种求100内数相加
//        int count = 0;
//        for (int i = 1; i <= 100; i++) {
//            count += i;
//        }
//        System.out.println(count);
//        第二种用高斯公式求，所以有种思路，可以先用算法推导公式，然后再应用在算法种
        //明显第二种方法更优因为只调用一次方法，然而第一个方法经历了好多次for循环

        //
        System.out.println(qiuhe(100));

    }

    public static int qiuhe(int n) {
        return n * (n + 1) / 2;
    }
}
